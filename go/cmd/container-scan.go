package cmd

import (
	"context"
	"fmt"
	"log"
	"os"
	"os/exec"

	"github.com/docker/docker/api/types"
	containertypes "github.com/docker/docker/api/types/container"

	"github.com/docker/docker/client"
	
	"github.com/go-git/go-git/v5"
)

var absPathDockerCompose string // global variable to store absolute path of filename.

func initialize() {
	fmt.Println("\nInitialize the scan...")
	// Localize docker-compose program
	FindDockerCompose()

	// Check mandatory programs for Docker_Bench_Security
	check_mandatory_commands()

	// We want to create the corresponding folders for Anchore, amd Docker Bench Security
	path, err := os.Getwd()
	if err != nil {
		log.Println(err)
	}

	Create_folder(path + "/Anchore")
	Create_folder(path + "/Docker-Bench-Security")
	Create_folder(path + "/Gitleaks")

	// Download the enablers configuration file and copy the file to the three folders
	DownloadFile("https://raw.githubusercontent.com/flopezag/fiware-security/develop/Common/enablers.json", "enablers.json")
	Copy_file("enablers.json", "./Anchore/enablers.json")

	// Clone the given repository to the given directory
	Info("    git clone https://github.com/docker/docker-bench-security.git")

	_, err = git.PlainClone(path+"/Docker-Bench-Security", false, &git.CloneOptions{
		URL:      "https://github.com/docker/docker-bench-security.git",
		Progress: os.Stdout,
	})

	Info("    %s\n", err)

	// Copy enablers.json to the Docker-Bench-Security folder and delete the file in the .. folder
	Copy_file("enablers.json", "./Docker-Bench-Security/enablers.json")
	err = os.Remove("enablers.json")
	CheckIfError(err)

	// Change to the Anchore directory
	err = os.Chdir("Anchore")
	CheckIfError(err)

	// Download the possible new version of the docker-compose.yaml file
	DownloadFile("https://engine.anchore.io/docs/quickstart/docker-compose.yaml", "docker-compose-anchore.yaml")

	// Start Anchore engine
	// #     redirect_all docker-compose -f docker-compose-anchore.yaml up -d
	fmt.Print("Starting Anchore engine... ")
	err = exec.Command(absPathDockerCompose, "compose", "-f", "docker-compose-anchore.yaml", "up", "-d").Run()
	if err != nil {
		fmt.Println(err.Error())
		os.Exit(-1)
	} else {
		fmt.Print("Success\n\n")
	}

	// Verify service availability

	// Wait until the vulnerabilities dictionary is download
	fmt.Print("Waiting vulnerability dictionary downloads... ")
	err = exec.Command(absPathDockerCompose, "compose", "-f docker-compose-anchore.yaml exec api anchore-cli system wait").Run()
	if err != nil {
		fmt.Println(err.Error())
		os.Exit(-1)
	} else {
		fmt.Print("Finished\n\n")
	}

	// Change to the Gitleaks directory
	// Initialize gitleaks rules
	InitRules()

	// Change to the original directory
	err = os.Chdir("..")
	CheckIfError(err)
}

func clean() {
	// TODO: The function stop and remove all containers that are presented in the computer. We should delete only those generated by the project.
	fmt.Println("Starting cleaning process...")
	
	// Stop/down the Anchore engine
	fmt.Print("    Clean up the Anchore docker-compose engine... ")

	err := os.Chdir("Anchore")
	CheckIfError(err)

	exec.Command(absPathDockerCompose, "compose", "-f docker-compose-anchore.yaml down")

	// Stop/down the Docker-Bench-Analysis engine
	// err = os.Chdir("../Docker-Bench-Security")
	// CheckIfError(err)

	fmt.Print("    Clean up the Docker-Bench-Security docker-compose engine... ")
	// exec.Command(absPathDockerCompose, "compose", "down")

	// Going back to the original folder
	err = os.Chdir("..")
	CheckIfError(err)

	// Clean all docker images
	fmt.Println("    Clean up all docker... ")
	ctx := context.Background()
	cli, err := client.NewClientWithOpts(client.FromEnv, client.WithAPIVersionNegotiation())
	if err != nil {
		panic(err)
	}

	containers, err := cli.ContainerList(ctx, types.ContainerListOptions{})
	if err != nil {
		panic(err)
	}

	for _, container := range containers {
		fmt.Print("        Stopping container ", container.ID[:10], "... ")
		stopTimeout := 3
		if err := cli.ContainerStop(ctx, container.ID, containertypes.StopOptions{Timeout: &stopTimeout}); err != nil {
			panic(err)
		}
		fmt.Println("Success")
	}

	for _, container := range containers {
		fmt.Print("        Removing container ", container.ID[:10], "... ")
		if err := cli.ContainerRemove(ctx, container.ID, types.ContainerRemoveOptions{
			RemoveVolumes: true,
			RemoveLinks:   false,
			Force:         true,
		}); err != nil {
			panic(err)
		}
		fmt.Println("Success")
	}

	images, err := cli.ImageList(ctx, types.ImageListOptions{})
	if err != nil {
		panic(err)
	}

	// Removing images, it should be only the images related to the GE scanned
	for _, image := range images {
	 	fmt.Print("        Removing image ", image.ID[:10], "... ")
	    if _, err := cli.ImageRemove(ctx, image.ID, types.ImageRemoveOptions{
			Force:         true,
			PruneChildren: true,
		}); err != nil {
	        panic(err)
	    }
	    fmt.Println("Success")
	}
}
